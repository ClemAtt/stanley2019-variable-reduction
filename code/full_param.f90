
subroutine makeGrid_fortran(nRows, nGrid, dx, dy, shear, rotate, turbs_per_row, x_start, &
                    & y0, turbineX, turbineY)

    implicit none

    ! define precision to be the standard for a double precision ! on local system
    integer, parameter :: dp = kind(0.d0)

    ! in
    integer, intent(in) :: nRows, nGrid
    real(dp), intent(in) :: dx, dy, shear, rotate, y0
    integer, dimension(nRows), intent(in) :: turbs_per_row
    real(dp), dimension(nRows), intent(in) ::  x_start

    ! out
    real(dp), dimension(nGrid), intent(out) :: turbineX, turbineY

    ! local
    integer :: i, j, index
    real(dp) :: rotate_rad, minx, maxx, miny, maxy, i_fl, j_fl
    real(dp), dimension(nGrid) :: x, y, xc, yc

    index = 1
    i_fl = 1.0
    do i = 1, nRows
        j_fl = 1.0
        do j = 1, turbs_per_row(i)
            x(index) = x_start(i)*dx + dx*j_fl + i_fl*shear
            y(index) = y0 + dy*i_fl
            index = index + 1
            j_fl = j_fl+1.0
        end do
        i_fl = i_fl+1.0
    end do

    minx = 100000000.0
    maxx = -100000000.0
    miny = 100000000.0
    maxy = -100000000.0
    do i = 1, nGrid
        if (x(i) < minx) then
            minx = x(i)
        end if
        if (x(i) > maxx) then
            maxx = x(i)
        end if
        if (y(i) < miny) then
            miny = y(i)
        end if
        if (y(i) > maxy) then
            maxy = y(i)
        end if
    end do

    xc = x - (maxx+minx)/2
    yc = y - (maxy+miny)/2
    rotate_rad = (rotate*3.1415926535)/180.0
    turbineX = cos(rotate_rad)*xc - sin(rotate_rad)*yc
    turbineY = sin(rotate_rad)*xc + cos(rotate_rad)*yc

end subroutine makeGrid_fortran


subroutine makeBoundary(nBounds, nOuter, boundX, boundY, start, &
                        &turbineX, turbineY)
  implicit none

  ! define precision to be the standard for a double precision ! on local system
  integer, parameter :: dp = kind(0.d0)

  ! in
  integer, intent(in) :: nBounds, nOuter
  real(dp), dimension(nBounds), intent(in) :: boundX, boundY
  real(dp), intent(in) :: start

  ! out
  real(dp), dimension(nOuter), intent(out) :: turbineX, turbineY

  ! local
  integer :: i, j, done
  real(dp), dimension(nBounds-1) :: lenBound
  real(dp) :: circumference, spacing, bound_loc

  do i = 1, nBounds-1
      lenBound(i) = sqrt((boundX(i+1)-boundX(i))**2+(boundY(i+1)-boundY(i))**2)
  end do

  circumference = sum(lenBound)
  spacing = circumference/nOuter
  bound_loc = start

  do i = 1, nOuter
      do while (bound_loc > circumference)
          bound_loc = bound_loc - circumference
      end do
      do while (bound_loc < 0.0)
          bound_loc = bound_loc + circumference
      end do
      done = 0
      do j = 1, nBounds
          if (done == 0) then
              if (bound_loc < sum(lenBound(:j))) then
                  turbineX(i) = boundX(j) + (boundX(j+1)-boundX(j))*(bound_loc-sum(lenBound(:j-1)))/lenBound(j)
                  turbineY(i) = boundY(j) + (boundY(j+1)-boundY(j))*(bound_loc-sum(lenBound(:j-1)))/lenBound(j)
                  done = 1
                  bound_loc = bound_loc + spacing
              end if
          end if
      end do
  end do

end subroutine makeBoundary


subroutine turbineLocations(nBounds, nRows, nTurbines, nOuter, nGrid, dx, dy, shear, rotate,&
                    & turbs_per_row, x_start, &
                    & y0, start, boundX, boundY, turbineX, turbineY)

  ! define precision to be the standard for a double precision ! on local system
  integer, parameter :: dp = kind(0.d0)

  ! in
  integer, intent(in) :: nBounds, nRows, nTurbines, nOuter, nGrid
  real(dp), dimension(nBounds), intent(in) :: boundX, boundY
  integer, dimension(nRows), intent(in) :: turbs_per_row
  real(dp), dimension(nRows), intent(in) ::  x_start
  real(dp), intent(in) :: dx, dy, shear, rotate, y0, start

  ! out
  real(dp), dimension(nTurbines), intent(out) :: turbineX, turbineY

  ! local
  real(dp), dimension(nOuter) :: outerX, outerY
  real(dp), dimension(nGrid) :: innerX, innerY


  call makeBoundary(nBounds, nOuter, boundX, boundY, start, &
                          &outerX, outerY)


  call makeGrid_fortran(nRows, nGrid, dx, dy, shear, rotate, turbs_per_row, x_start, &
                      & y0, innerX, innerY)

  turbineX(:nOuter) = outerX
  turbineY(:nOuter) = outerY

  turbineX(nOuter+1:) = innerX
  turbineY(nOuter+1:) = innerY

end subroutine turbineLocations






!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:31
!
!  Differentiation of makegrid_fortran in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: turbinex turbiney
!   with respect to varying inputs: rotate dx dy shear
SUBROUTINE MAKEGRID_FORTRAN_DV(nrows, ngrid, dx, dxd, dy, dyd, shear, &
& sheard, rotate, rotated, turbs_per_row, x_start, y0, turbinex, &
& turbinexd, turbiney, turbineyd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nrows, ngrid
  REAL(dp), INTENT(IN) :: dx, dy, shear, rotate, y0
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: dxd, dyd, sheard, &
& rotated
  INTEGER, DIMENSION(nrows), INTENT(IN) :: turbs_per_row
  REAL(dp), DIMENSION(nrows), INTENT(IN) :: x_start
! out
  REAL(dp), DIMENSION(ngrid), INTENT(OUT) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, ngrid), INTENT(OUT) :: turbinexd, &
& turbineyd
! local
  INTEGER :: i, j, index
  REAL(dp) :: rotate_rad, minx, maxx, miny, maxy, i_fl, j_fl
  REAL(dp), DIMENSION(nbdirs) :: rotate_radd, minxd, maxxd, minyd, &
& maxyd
  REAL(dp), DIMENSION(ngrid) :: x, y, xc, yc
  REAL(dp), DIMENSION(nbdirs, ngrid) :: xd, yd, xcd, ycd
  INTRINSIC COS
  INTRINSIC SIN
  INTEGER :: nd
  INTEGER :: nbdirs
  index = 1
  i_fl = 1.0
  xd(:, :) = 0.0_8
  yd(:, :) = 0.0_8
  DO i=1,nrows
    j_fl = 1.0
    DO j=1,turbs_per_row(i)
      DO nd=1,nbdirs
        xd(nd, index) = x_start(i)*dxd(nd) + j_fl*dxd(nd) + i_fl*sheard(&
&         nd)
        yd(nd, index) = i_fl*dyd(nd)
      END DO
      x(index) = x_start(i)*dx + dx*j_fl + i_fl*shear
      y(index) = y0 + dy*i_fl
      index = index + 1
      j_fl = j_fl + 1.0
    END DO
    i_fl = i_fl + 1.0
  END DO
  minx = 100000000.0
  maxx = -100000000.0
  miny = 100000000.0
  maxy = -100000000.0
  minxd(:) = 0.0_8
  minyd(:) = 0.0_8
  maxxd(:) = 0.0_8
  maxyd(:) = 0.0_8
  DO i=1,ngrid
    IF (x(i) .LT. minx) THEN
      DO nd=1,nbdirs
        minxd(nd) = xd(nd, i)
      END DO
      minx = x(i)
    END IF
    IF (x(i) .GT. maxx) THEN
      DO nd=1,nbdirs
        maxxd(nd) = xd(nd, i)
      END DO
      maxx = x(i)
    END IF
    IF (y(i) .LT. miny) THEN
      DO nd=1,nbdirs
        minyd(nd) = yd(nd, i)
      END DO
      miny = y(i)
    END IF
    IF (y(i) .GT. maxy) THEN
      DO nd=1,nbdirs
        maxyd(nd) = yd(nd, i)
      END DO
      maxy = y(i)
    END IF
  END DO
  xc = x - (maxx+minx)/2
  yc = y - (maxy+miny)/2
  rotate_rad = rotate*3.1415926535/180.0
  DO nd=1,nbdirs
    xcd(nd, :) = xd(nd, :) - (maxxd(nd)+minxd(nd))/2
    ycd(nd, :) = yd(nd, :) - (maxyd(nd)+minyd(nd))/2
    rotate_radd(nd) = 3.1415926535*rotated(nd)/180.0
    turbinexd(nd, :) = COS(rotate_rad)*xcd(nd, :) - rotate_radd(nd)*SIN(&
&     rotate_rad)*xc - rotate_radd(nd)*COS(rotate_rad)*yc - SIN(&
&     rotate_rad)*ycd(nd, :)
    turbineyd(nd, :) = rotate_radd(nd)*COS(rotate_rad)*xc + SIN(&
&     rotate_rad)*xcd(nd, :) + COS(rotate_rad)*ycd(nd, :) - rotate_radd(&
&     nd)*SIN(rotate_rad)*yc
  END DO
  turbinex = COS(rotate_rad)*xc - SIN(rotate_rad)*yc
  turbiney = SIN(rotate_rad)*xc + COS(rotate_rad)*yc
END SUBROUTINE MAKEGRID_FORTRAN_DV

!  Differentiation of makeboundary in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: turbinex turbiney
!   with respect to varying inputs: start
SUBROUTINE MAKEBOUNDARY_DV(nbounds, nouter, boundx, boundy, start, &
& startd, turbinex, turbinexd, turbiney, turbineyd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nbounds, nouter
  REAL(dp), DIMENSION(nbounds), INTENT(IN) :: boundx, boundy
  REAL(dp), INTENT(IN) :: start
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: startd
! out
  REAL(dp), DIMENSION(nouter), INTENT(OUT) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nouter), INTENT(OUT) :: turbinexd, &
& turbineyd
! local
  INTEGER :: i, j, done
  REAL(dp), DIMENSION(nbounds-1) :: lenbound
  REAL(dp) :: circumference, spacing, bound_loc
  REAL(dp), DIMENSION(nbdirs) :: bound_locd
  INTRINSIC SQRT
  INTRINSIC SUM
  REAL(dp) :: arg1
  INTEGER :: nd
  INTEGER :: nbdirs
  DO i=1,nbounds-1
    arg1 = (boundx(i+1)-boundx(i))**2 + (boundy(i+1)-boundy(i))**2
    lenbound(i) = SQRT(arg1)
  END DO
  circumference = SUM(lenbound)
  spacing = circumference/nouter
  DO nd=1,nbdirs
    bound_locd(nd) = startd(nd)
  END DO
  bound_loc = start
  turbinexd(:, :) = 0.0_8
  turbineyd(:, :) = 0.0_8
  DO i=1,nouter
    DO WHILE (bound_loc .GT. circumference)
      bound_loc = bound_loc - circumference
    END DO
    DO WHILE (bound_loc .LT. 0.0)
      bound_loc = bound_loc + circumference
    END DO
    done = 0
    DO j=1,nbounds
      IF (done .EQ. 0) THEN
        IF (bound_loc .LT. SUM(lenbound(:j))) THEN
          DO nd=1,nbdirs
            turbinexd(nd, i) = (boundx(j+1)-boundx(j))*bound_locd(nd)/&
&             lenbound(j)
            turbineyd(nd, i) = (boundy(j+1)-boundy(j))*bound_locd(nd)/&
&             lenbound(j)
          END DO
          turbinex(i) = boundx(j) + (boundx(j+1)-boundx(j))*(bound_loc-&
&           SUM(lenbound(:j-1)))/lenbound(j)
          turbiney(i) = boundy(j) + (boundy(j+1)-boundy(j))*(bound_loc-&
&           SUM(lenbound(:j-1)))/lenbound(j)
          done = 1
          bound_loc = bound_loc + spacing
        END IF
      END IF
    END DO
  END DO
END SUBROUTINE MAKEBOUNDARY_DV

!  Differentiation of turbinelocations in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: turbinex turbiney
!   with respect to varying inputs: rotate dx dy start shear
!   RW status of diff variables: turbinex:out turbiney:out rotate:in
!                dx:in dy:in start:in shear:in
SUBROUTINE TURBINELOCATIONS_DV(nbounds, nrows, nturbines, nouter, ngrid&
& , dx, dxd, dy, dyd, shear, sheard, rotate, rotated, turbs_per_row, &
& x_start, y0, start, startd, boundx, boundy, turbinex, turbinexd, &
& turbiney, turbineyd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nbounds, nrows, nturbines, nouter, ngrid
  REAL(dp), DIMENSION(nbounds), INTENT(IN) :: boundx, boundy
  INTEGER, DIMENSION(nrows), INTENT(IN) :: turbs_per_row
  REAL(dp), DIMENSION(nrows), INTENT(IN) :: x_start
  REAL(dp), INTENT(IN) :: dx, dy, shear, rotate, y0, start
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: dxd, dyd, sheard, &
& rotated, startd
! out
  REAL(dp), DIMENSION(nturbines), INTENT(OUT) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(OUT) :: turbinexd, &
& turbineyd
! local
  REAL(dp), DIMENSION(nouter) :: outerx, outery
  REAL(dp), DIMENSION(nbdirs, nouter) :: outerxd, outeryd
  REAL(dp), DIMENSION(ngrid) :: innerx, innery
  REAL(dp), DIMENSION(nbdirs, ngrid) :: innerxd, inneryd
  INTEGER :: nd
  INTEGER :: nbdirs
  CALL MAKEBOUNDARY_DV(nbounds, nouter, boundx, boundy, start, startd, &
&                outerx, outerxd, outery, outeryd, nbdirs)
  CALL MAKEGRID_FORTRAN_DV(nrows, ngrid, dx, dxd, dy, dyd, shear, sheard&
&                    , rotate, rotated, turbs_per_row, x_start, y0, &
&                    innerx, innerxd, innery, inneryd, nbdirs)
  turbinexd(:, :) = 0.0_8
  turbineyd(:, :) = 0.0_8
  DO nd=1,nbdirs
    turbinexd(nd, :nouter) = outerxd(nd, :)
    turbineyd(nd, :nouter) = outeryd(nd, :)
    turbinexd(nd, nouter+1:) = innerxd(nd, :)
    turbineyd(nd, nouter+1:) = inneryd(nd, :)
  END DO
  turbinex(:nouter) = outerx
  turbiney(:nouter) = outery
  turbinex(nouter+1:) = innerx
  turbiney(nouter+1:) = innery
END SUBROUTINE TURBINELOCATIONS_DV
