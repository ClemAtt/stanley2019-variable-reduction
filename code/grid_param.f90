
subroutine makeGrid_fortran(nRows, nTurbines, dx, dy, shear, rotate, turbs_per_row, x_start, &
                    & y0, turbineX, turbineY)

    implicit none

    ! define precision to be the standard for a double precision ! on local system
    integer, parameter :: dp = kind(0.d0)

    ! in
    integer, intent(in) :: nRows, nTurbines
    real(dp), intent(in) :: dx, dy, shear, rotate, y0
    integer, dimension(nRows), intent(in) :: turbs_per_row
    real(dp), dimension(nRows), intent(in) ::  x_start

    ! out
    real(dp), dimension(nTurbines), intent(out) :: turbineX, turbineY

    ! local
    integer :: i, j, index
    real(dp) :: rotate_rad, minx, maxx, miny, maxy, i_fl, j_fl
    real(dp), dimension(nTurbines) :: x, y, xc, yc

    index = 1
    i_fl = 1.0
    do i = 1, nRows
        j_fl = 1.0
        do j = 1, turbs_per_row(i)
            x(index) = x_start(i)*dx + dx*j_fl + i_fl*shear
            y(index) = y0 + dy*i_fl
            index = index + 1
            j_fl = j_fl+1.0
        end do
        i_fl = i_fl+1.0
    end do

    minx = 100000000.0
    maxx = -100000000.0
    miny = 100000000.0
    maxy = -100000000.0
    do i = 1, nTurbines
        if (x(i) < minx) then
            minx = x(i)
        end if
        if (x(i) > maxx) then
            maxx = x(i)
        end if
        if (y(i) < miny) then
            miny = y(i)
        end if
        if (y(i) > maxy) then
            maxy = y(i)
        end if
    end do

    xc = x - (maxx+minx)/2
    yc = y - (maxy+miny)/2
    rotate_rad = (rotate*3.1415926535)/180.0
    turbineX = cos(rotate_rad)*xc - sin(rotate_rad)*yc
    turbineY = sin(rotate_rad)*xc + cos(rotate_rad)*yc

end subroutine makeGrid_fortran




!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.14 (r7259) - 18 Jan 2019 09:31
!
!  Differentiation of makegrid_fortran in forward (tangent) mode (with options multiDirectional i4 dr8 r4):
!   variations   of useful results: turbinex turbiney
!   with respect to varying inputs: rotate dx dy shear
!   RW status of diff variables: turbinex:out turbiney:out rotate:in
!                dx:in dy:in shear:in
SUBROUTINE MAKEGRID_FORTRAN_DV(nrows, nturbines, dx, dxd, dy, dyd, shear&
& , sheard, rotate, rotated, turbs_per_row, x_start, y0, turbinex, &
& turbinexd, turbiney, turbineyd, nbdirs)

!  Hint: nbdirs should be the maximum number of differentiation directions
  IMPLICIT NONE
  INTRINSIC KIND
! define precision to be the standard for a double precision ! on local system
  INTEGER, PARAMETER :: dp=KIND(0.d0)
! in
  INTEGER, INTENT(IN) :: nrows, nturbines
  REAL(dp), INTENT(IN) :: dx, dy, shear, rotate, y0
  REAL(dp), DIMENSION(nbdirs), INTENT(IN) :: dxd, dyd, sheard, &
& rotated
  INTEGER, DIMENSION(nrows), INTENT(IN) :: turbs_per_row
  REAL(dp), DIMENSION(nrows), INTENT(IN) :: x_start
! out
  REAL(dp), DIMENSION(nturbines), INTENT(OUT) :: turbinex, turbiney
  REAL(dp), DIMENSION(nbdirs, nturbines), INTENT(OUT) :: turbinexd, &
& turbineyd
! local
  INTEGER :: i, j, index
  REAL(dp) :: rotate_rad, minx, maxx, miny, maxy, i_fl, j_fl
  REAL(dp), DIMENSION(nbdirs) :: rotate_radd, minxd, maxxd, minyd, &
& maxyd
  REAL(dp), DIMENSION(nturbines) :: x, y, xc, yc
  REAL(dp), DIMENSION(nbdirs, nturbines) :: xd, yd, xcd, ycd
  INTRINSIC COS
  INTRINSIC SIN
  INTEGER :: nd
  INTEGER :: nbdirs
  index = 1
  i_fl = 1.0
  xd(:, :) = 0.0_8
  yd(:, :) = 0.0_8
  DO i=1,nrows
    j_fl = 1.0
    DO j=1,turbs_per_row(i)
      DO nd=1,nbdirs
        xd(nd, index) = x_start(i)*dxd(nd) + j_fl*dxd(nd) + i_fl*sheard(&
&         nd)
        yd(nd, index) = i_fl*dyd(nd)
      END DO
      x(index) = x_start(i)*dx + dx*j_fl + i_fl*shear
      y(index) = y0 + dy*i_fl
      index = index + 1
      j_fl = j_fl + 1.0
    END DO
    i_fl = i_fl + 1.0
  END DO
  minx = 100000000.0
  maxx = -100000000.0
  miny = 100000000.0
  maxy = -100000000.0
  minxd(:) = 0.0_8
  minyd(:) = 0.0_8
  maxxd(:) = 0.0_8
  maxyd(:) = 0.0_8
  DO i=1,nturbines
    IF (x(i) .LT. minx) THEN
      DO nd=1,nbdirs
        minxd(nd) = xd(nd, i)
      END DO
      minx = x(i)
    END IF
    IF (x(i) .GT. maxx) THEN
      DO nd=1,nbdirs
        maxxd(nd) = xd(nd, i)
      END DO
      maxx = x(i)
    END IF
    IF (y(i) .LT. miny) THEN
      DO nd=1,nbdirs
        minyd(nd) = yd(nd, i)
      END DO
      miny = y(i)
    END IF
    IF (y(i) .GT. maxy) THEN
      DO nd=1,nbdirs
        maxyd(nd) = yd(nd, i)
      END DO
      maxy = y(i)
    END IF
  END DO
  xc = x - (maxx+minx)/2
  yc = y - (maxy+miny)/2
  rotate_rad = rotate*3.1415926535/180.0
  DO nd=1,nbdirs
    xcd(nd, :) = xd(nd, :) - (maxxd(nd)+minxd(nd))/2
    ycd(nd, :) = yd(nd, :) - (maxyd(nd)+minyd(nd))/2
    rotate_radd(nd) = 3.1415926535*rotated(nd)/180.0
    turbinexd(nd, :) = COS(rotate_rad)*xcd(nd, :) - rotate_radd(nd)*SIN(&
&     rotate_rad)*xc - rotate_radd(nd)*COS(rotate_rad)*yc - SIN(&
&     rotate_rad)*ycd(nd, :)
    turbineyd(nd, :) = rotate_radd(nd)*COS(rotate_rad)*xc + SIN(&
&     rotate_rad)*xcd(nd, :) + COS(rotate_rad)*ycd(nd, :) - rotate_radd(&
&     nd)*SIN(rotate_rad)*yc
  END DO
  turbinex = COS(rotate_rad)*xc - SIN(rotate_rad)*yc
  turbiney = SIN(rotate_rad)*xc + COS(rotate_rad)*yc
END SUBROUTINE MAKEGRID_FORTRAN_DV
